<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Topics on .dom Documentation</title>
    <link>http://example.org/docs/topics/</link>
    <description>Recent content in Topics on .dom Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/docs/topics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Quick Start</title>
      <link>http://example.org/docs/topics/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/quick-start/</guid>
      <description> Quick Start The smallest .dom example looks like this:
R( H(&amp;#34;p&amp;#34;, &amp;#34;Hello World&amp;#34;), document.body ); It displays a paragraph, saying &amp;ldquo;Hello World&amp;rdquo; in the page, using the Declarative DOM Composition syntax.
Feel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:
Try it in CodePen
Next Topic  Declarative DOM &amp;rarr;     </description>
    </item>
    
    <item>
      <title>Declarative DOM</title>
      <link>http://example.org/docs/topics/declarative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/declarative/</guid>
      <description>Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.
This is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:
div( div.underline( &amp;#34;Welcome!&amp;#34; ), p( &amp;#34;In this example we demonstrate &amp;#34;, &amp;#34;the &amp;#34;, b(&amp;#34;.dom&amp;#34;), &amp;#34; accelerators.&amp;#34; ), p( &amp;#34;Create &amp;#34;, span.</description>
    </item>
    
    <item>
      <title>Components</title>
      <link>http://example.org/docs/topics/components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/components/</guid>
      <description>Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return Virtual DOM elements describing what should appear on the screen.
Component Functions All components in .dom are Javascript functions:
const { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); }  This function is a valid .</description>
    </item>
    
    <item>
      <title>Stateful Components</title>
      <link>http://example.org/docs/topics/stateful-components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/stateful-components/</guid>
      <description>Stateful Components Components can only carry properties given, but can also maintain their own state.
For example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:
const { div, button } = H; function Spinner(props) { return div.fullspan( button(&amp;#34;-&amp;#34;), div(`${props.value}`), button(&amp;#34;&amp;#43;&amp;#34;) ); } R(H(Spinner, {value: 0}), document.body); But what should happen when the user clicks the &amp;ldquo;+&amp;rdquo; or the &amp;ldquo;-&amp;rdquo; button?</description>
    </item>
    
    <item>
      <title>Component Lifecycle</title>
      <link>http://example.org/docs/topics/component-lifecycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/component-lifecycle/</guid>
      <description>Component Lifecycle Every .dom component undergoes through a three phases during it&amp;rsquo;s life-cycle : Mounted, Updated and Unmounted
As a developer, you can react to these life-cycle events in order to implement your logic.
Component Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:
function Component(props, state, setState, hooks) { // .</description>
    </item>
    
    <item>
      <title>Raw Nodes</title>
      <link>http://example.org/docs/topics/raw/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/raw/</guid>
      <description> Raw (Unreconciled) Nodes test
const RawComponent = (props, state, setState, hooks) =&amp;gt; { // Mark the component as raw  hooks.r = 1; }   Previous Topic  &amp;larr; Component Lifecycle    Next Topic  Keyed Updates &amp;rarr;     </description>
    </item>
    
    <item>
      <title>Keyed Updates</title>
      <link>http://example.org/docs/topics/keyed-updates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/topics/keyed-updates/</guid>
      <description> Keyed Updates  Previous Topic  &amp;larr; Raw Nodes     </description>
    </item>
    
  </channel>
</rss>